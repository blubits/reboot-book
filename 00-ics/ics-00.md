---
title: Solving problems
module: 0
lesson: 0
status: incomplete
objectives:
    * Introduce students to problem-solving in computer science
---

# Solving problems

> I travel a lot around the city. I usually just hop on a train to somewhere to travel - every building is within a five-minute walk from a station, so there's no problem getting around.
>
> Problem is, our train network is so complex that it's hard to see the quickest way to get from one station to another. I do have a map of all the stations in our train network, and how fast it usually takes for a train to get from one station to another, along with wait times for each station.
>
> Given an origin and destination station, can you help me traverse the train network in the fastest possible way?

At first glance, computer science seems like just the study of computers - how to work with them and how to manipulate them to serve their being. But as telescopes are simply an astronomer's tool, computers are only a physical representation, a machine that makes computer scientists' lives easier.

Computer science is, at its core, about *computation*. Given a certain problem, we want to find out how to build something that can easily solve it. In 1936, Turing theorized that all you needed were two numbers, an infinite string of tape, and a way to see and change a certain point of that tape. Since then, we've built a whole field of study dedicated to the what, why, and how of computing.

But we're not here to study the internals of computing. The essence of computing is something called the *algorithm*, a step by step method on how to solve a certain problem.

To the unsuspecting eye, an algorithm is a black box. Given a certain set of *inputs*, the algorithm works its magic to get a set of *outputs* that say the correct answer. A good computer scientist, however, knows that inside the black box is simply mathematical and computational genius. With a little bit of manipulation and a little bit of modeling, algorithms can solve the simplest of problems, and the most complex of problems.

Developing a good algorithm, then, is simply a matter of knowing how to model, how to process, and how to manipulate data to get a solution. It's a little bit like solving a complicated Math problem - bridging concepts together to create a grand solution - but you're a little less prone to carelessness and a little more prone to stupidity.

## So how do we develop a good algorithm?

Good question. A good algorithm designer knows that their algorithm must follow these qualities to be a good solution to a problem:

### An algorithm is correct.

*Duh*, you might say. Of course an algorithm must be correct to solve a problem!
